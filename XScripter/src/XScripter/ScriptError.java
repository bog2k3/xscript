package XScripter;

/**
 * this class describes an error generated by the compiler
**/
public class ScriptError
{
	/** The code of the error. */
	public ScriptErrorCode Code;
	/** line of code where the error occured. */
	public int Line;
	/** the function in which the error occured */
	public String Function;
	/** additional info about the error. */
	public String Info;
	
	Script CurrentScript = null;

	ScriptError(ScriptErrorCode code, Script crtScript, int line, Function function, String info)
	{
		Code = code;
		Line = line;
		Function = function == null ? "(none)" : function.Name;
		Info = info;
		CurrentScript = crtScript;
	}

	/** Creates a string representation of the error. */
	@Override
	public String toString()
	{
		String s = (CurrentScript != null ? "Script: "+CurrentScript.FileName+", " : "") + 
			"Line: " + Integer.toString(Line) + " \nFunction: " + Function + "\n";
		switch (Code)
		{
			case TypeIDExpected:
				s += "Type identifier expected.";
				break;
			case IdentifierExpected:
				s += "Identifier expected.";
				break;
			case VarCannotBeVoid:
				s += "Variables cannot be of type VOID.";
				break;
			case IllegalChar:
				s += "Illegal character.";
				break;
			case FnPostHdrExpected:
				s += "'{' or ';' expected after function header.";
				break;
			case FnAlreadyDef:
				s += "Function already defined.";
				break;
			case LBraceExpected:
				s += "'{' expected.";
				break;
			case RBraceExpected:
				s += "'}' expected.";
				break;
			case UnknownIdent:
				s += "Unknown identifier.";
				break;
			case Syntax:
				s += "Syntax error.";
				break;
			case LBracketExpected:
				s += "'(' expected.";
				break;
			case RBracketExpected:
				s += "')' expected.";
				break;
			case RightIndexBracketExpected:
				s += "']' expected.";
				break;
			case SemiColonExpected:
				s += "';' expected.";
				break;
			case IncompatTypeOp:
				s += "Incompatible types or operators in expression.";
				break;
			case ReadonlyFunc:
				s += "readonly cannot be specified for functions and constructors.";
				break;
			case ReadonlyModify:
				s += "readonly variables/fields cannot be modified.";
				break;
			case InvalidArrayType:
				s += "Invalid array type.";
				break;
			case ArraySizeExpected:
				s += "Expected array size specifier.";
				break;
			case InvalidArraySizeSpecifier:
				s += "Incompatible array size type.";
				break;
			case DuplicateIdentifier:
				s += "Duplicate identifier.";
				break;
			case OverloadNotFound:
				s += "No overload found matching all parameter types.";
				break;
			case OverloadOnlyReturn:
				s += "Overloaded function cannot differ only by return type.";
				break;
			case FuncDefMissing:
				s += "Function was declared but never defined a body.";
				break;
			case ReservedWordUsed:
				s += "Reserved words cannot be used as identifiers.";
				break;
			case VarNeverUsed:
				s += "Variable was declared, but never used. This could be caused by variables declared in a single instruction sub-scope.";
				break;
			case IllegalBreak:
				s += "Illegal break. No enclosing 'for', 'while' or 'do' statements.";
				break;
			case FuncCannotRetValue:
				s += "Function return type is VOID. Therefore it cannot return a value.";
				break;
			case EmptyBlock:
				s += "Empty code block detected.";
				break;
			case UnreachableCode:
				s += "Unreachable code detected. Possibly miss-placed return statement.";
				break;
			case MissingRet:
				s += "Function must return a value.";
				break;
			case VoidFuncInExpr:
				s += "Void functions cannot be used in expressions.";
				break;
			case QuoteExpected:
				s += "'\"' Expected.";
				break;
			case EndOfFile:
				s += "Unexpected end of file.";
				break;
			case UntilExpected:
				s += "<until> reserved word expected after <do> statement";
				break;
			case IncompleteReturnPath:
				s += "Not all execution paths return a value.";
				break;
			case ObjTypeExpected:
				s += "<ClassType> is missing in \"object\" type variable declaration.";
				break;
			case FuncBodyInClass:
				s += "Methods inside classes cannot define a body. The methods are implemented externally.";
				break;
			case DelimiterExpected:
				s += "; or , expected.";
				break;
			case InvalidClass:
				s += "Class cannot be registered because it does not implement IScriptable interface.";
				break;
			case EmptyCtorNotFound:
				s += "Class does not have a public default constructor.";
				break;
			case CannotInstantiateClass:
				s += "Could not instantiate external class.";
				break;
			case ClassMismatch:
				s += "Class could not be validated. Reason: internal/external description mismatch.";
				break;
			case IllegalDirective:
				s += "Illegal directive placement (directives can only be placed outside classes and functions, at the beginning of the script).";
				break;
			case DirectiveExpected:
				s += "Directive expected.";
				break;
			case UnknownDirective:
				s += "Unknown directive.";
				break;
			case UnitDirectiveRecurence:
				s += "#unit directive can only appear once in the script.";
				break;
			case DuplicateLibraryName:
				s += "A library with the same name has already been registered.";
				break;
			case LibraryNotFound:
				s += "Library could not be found.";
				break;
			case LibraryNotCompiled:
				s += "The library is not compiled.";
				break;
			case UnknownExtGlobalClassType:
				s += "The Class Type of the external global is unknown. (Did you forget to import a library?)";
				break;
			case GenericObjectAccess:
				s += "Cannot use '.' operator on  generic \"object<>\" type.";
				break;
			case ClassIdentExpected:
				s += "Class identifier expected for base class.";
				break;
			case AbstractInstantiate:
				s += "Cannot instantiate an abstract class.";
				break;
			case ClassExpected:
				s += "class expected after external.";
				break;
			case GlobalInit:
				s += "Global variables may not be initialized.";
				break;
			case FieldInit:
				s += "Class fields may not be initialized in the script.";
				break;
			case ClassAlreadyDefined:
				s += "This class has already been defined. Cannot redefine it.";
				break;
			case ClassDefMissing:
				s += "Class has been referenced, but not defined.";
				break;
			case EventOutsideClass:
				s += "Events cannot be declared outside classes.";
				break;
			case DuplicateEvent:
				s += "An event with this name has already been defined for this class.";
				break;
			case EventBody:
				s += "An event cannot define a body.";
				break;
			case InvalidEvHandler:
				s += "No prototype for the assigned handler matches the event signature.";
				break;
			case ExternalFunc:
				s += "Functions cannot be external.";
				break;
			case ExtVarNotFound:
				s += "External variable does not exist.";
				break;
			case IllegalModifier:
				s += "Illegal modifier.";
				break;
			case NoLibraryFetcher:
				s += "No library fetcher registered for importing libraries.";
				break;
			case StaticOutsideClass:
				s += "static modifier cannot be used outside classes.";
				break;
			case StaticAccessThroughInstance:
				s += "Cannot access a static member through an object instance. Use the class name instead.";
				break;
			case Unknown:
			default:
				s += "Unknown error";
				break;
		}

		if (Info != null)
			s += "\n" + Info + "\n========================================\n";
		return s;
	}
}
